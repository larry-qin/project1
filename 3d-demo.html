<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Horror Maze - Escape the Raccoon</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .demo-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 80vh;
            padding: 2rem;
        }

        .demo-title {
            margin-bottom: 2rem;
            text-align: center;
        }

        #canvas-container {
            width: 100%;
            max-width: 1000px;
            height: 700px;
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .game-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        .click-to-play {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            color: white;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid var(--accent-color);
            animation: pulse 2s infinite;
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 150;
            pointer-events: none;
            display: none;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }

        .crosshair::before {
            width: 20px;
            height: 2px;
            top: -1px;
            left: -10px;
        }

        .crosshair::after {
            width: 2px;
            height: 20px;
            top: -10px;
            left: -1px;
        }

        .pistol-2d {
            position: absolute;
            bottom: 0;
            right: 150px;
            width: 600px;
            height: 450px;
            z-index: 140;
            pointer-events: none;
            display: none;
            transform-origin: center bottom;
            transition: transform 0.1s ease;
        }

        .weapon-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .bullet-path {
            position: absolute;
            width: 2px;
            height: 0;
            background: linear-gradient(to bottom, #ffff00, #ff0000);
            opacity: 0;
            z-index: 125;
            pointer-events: none;
            transform-origin: top center;
        }

        @keyframes bulletPath {
            0% {
                opacity: 1;
                height: 0;
            }
            50% {
                opacity: 1;
                height: 100%;
            }
            100% {
                opacity: 0;
                height: 100%;
            }
        }

        @keyframes recoil {
            0% { transform: translateX(0) translateY(0) scale(1); }
            50% { transform: translateX(-15px) translateY(-8px) scale(0.95); }
            100% { transform: translateX(0) translateY(0) scale(1); }
        }

        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }

        .minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--accent-color);
            border-radius: 8px;
            z-index: 100;
        }

        .help-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .help-modal {
            background: linear-gradient(145deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.9));
            border: 2px solid var(--accent-color);
            border-radius: 15px;
            padding: 2rem;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            color: white;
            font-family: monospace;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5),
                        0 0 0 1px rgba(100, 255, 218, 0.2),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transform: translateY(-10px);
            animation: floatIn 0.4s ease-out forwards;
        }

        @keyframes floatIn {
            from {
                opacity: 0;
                transform: translateY(20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(-10px) scale(1);
            }
        }

        .help-modal:hover {
            transform: translateY(-12px);
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.6),
                        0 0 0 1px rgba(100, 255, 218, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        .help-header {
            text-align: center;
            margin-bottom: 2rem;
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 1rem;
        }

        .help-header h2 {
            color: var(--accent-color);
            margin: 0 0 0.5rem 0;
        }

        .help-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .help-section {
            background: rgba(var(--accent-rgb), 0.1);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--accent-color);
        }

        .help-section h3 {
            color: var(--accent-color);
            margin-top: 0;
            margin-bottom: 1rem;
        }

        .help-controls {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .help-controls li {
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .key-combo {
            background: var(--card-background);
            border: 1px solid var(--border-color);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
            color: var(--accent-color);
            min-width: 60px;
            text-align: center;
        }

        .help-footer {
            text-align: center;
            border-top: 1px solid var(--border-color);
            padding-top: 1rem;
        }

        .close-btn {
            background: linear-gradient(145deg, var(--accent-color), rgba(100, 255, 218, 0.8));
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(100, 255, 218, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        .close-btn:hover {
            background: linear-gradient(145deg, rgba(100, 255, 218, 0.9), var(--accent-color));
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(100, 255, 218, 0.4),
                        inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .close-btn:active {
            transform: translateY(-1px);
            box-shadow: 0 2px 10px rgba(100, 255, 218, 0.3);
        }

        .controls {
            margin-top: 2rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .cicd-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .cicd-modal {
            background: linear-gradient(145deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.9));
            border: 2px solid var(--accent-color);
            border-radius: 15px;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            backdrop-filter: blur(10px);
            color: white;
            font-family: monospace;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5),
                        0 0 0 1px rgba(100, 255, 218, 0.2),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            animation: floatIn 0.4s ease-out forwards;
        }

        .cicd-header {
            text-align: center;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 1rem;
        }

        .cicd-header h2 {
            color: var(--accent-color);
            margin: 0;
        }

        .cicd-checklist {
            margin: 1.5rem 0;
        }

        .cicd-test-item {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            margin: 0.5rem 0;
            background: rgba(var(--accent-rgb), 0.1);
            border-radius: 8px;
            border: 1px solid rgba(var(--accent-rgb), 0.3);
        }

        .cicd-test-status {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            margin-right: 1rem;
            background: #333;
            border: 2px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .cicd-test-status.pending {
            background: #333;
            border-color: #666;
        }

        .cicd-test-status.pass {
            background: #22c55e;
            border-color: #16a34a;
        }

        .cicd-test-status.fail {
            background: #ef4444;
            border-color: #dc2626;
        }

        .cicd-test-name {
            flex: 1;
            font-weight: bold;
        }

        .cicd-results {
            margin-top: 1.5rem;
            padding: 1rem;
            border-radius: 8px;
            border: 2px solid;
            text-align: center;
            font-weight: bold;
            display: none;
        }

        .cicd-results.success {
            background: rgba(34, 197, 94, 0.2);
            border-color: #22c55e;
            color: #22c55e;
        }

        .cicd-results.failure {
            background: rgba(239, 68, 68, 0.2);
            border-color: #ef4444;
            color: #ef4444;
        }

        .cicd-results-details {
            margin-top: 0.75rem;
            font-size: 14px;
            font-weight: normal;
            text-align: left;
        }

        .cicd-footer {
            text-align: center;
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
        }

        .run-test-btn {
            background: linear-gradient(145deg, var(--accent-color), rgba(100, 255, 218, 0.8));
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(100, 255, 218, 0.3);
            margin-right: 0.5rem;
        }

        .run-test-btn:hover {
            background: linear-gradient(145deg, rgba(100, 255, 218, 0.9), var(--accent-color));
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(100, 255, 218, 0.4);
        }

        .run-test-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .control-btn {
            padding: 0.5rem 1rem;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-2px);
        }

        .demo-info {
            max-width: 800px;
            text-align: center;
            margin-top: 2rem;
            padding: 1.5rem;
            background: var(--card-background);
            border-radius: 10px;
            border: 1px solid var(--border-color);
        }

        .instructions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
            text-align: left;
        }

        .instruction-group {
            background: rgba(var(--accent-rgb), 0.1);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--accent-color);
        }

        @media (max-width: 768px) {
            #canvas-container {
                height: 500px;
            }

            .demo-container {
                padding: 1rem;
            }

            .minimap {
                width: 150px;
                height: 150px;
            }

            .game-ui {
                font-size: 12px;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <header>
        <nav>
            <div class="logo">
                <h1>John Doe</h1>
            </div>
            <div class="nav-container">
                <ul class="nav-links">
                    <li><a href="index.html">Home</a></li>
                    <li><a href="3d-demo.html" class="active">3D Demo</a></li>
                </ul>
                <div class="theme-switcher">
                    <button id="theme-toggle" class="theme-btn">üé®</button>
                    <div id="theme-menu" class="theme-menu">
                        <div class="theme-option" data-theme="dark">Dark</div>
                        <div class="theme-option" data-theme="blue">Ocean</div>
                        <div class="theme-option" data-theme="purple">Sunset</div>
                        <div class="theme-option" data-theme="green">Forest</div>
                    </div>
                </div>
            </div>
        </nav>
    </header>

    <main>
        <div class="demo-container">
            <div class="demo-title">
                <h1>HORROR MAZE - Escape the Raccoon</h1>
                <p>Navigate the dark maze and survive. The raccoon is hunting you...</p>
            </div>

            <div id="canvas-container">
                <div class="game-ui">
                    <div>Position: <span id="position">0, 0</span></div>
                    <div>Health: <span id="player-health" style="color: #22c55e; font-weight: bold;">100</span></div>
                    <div>Raccoon Kills: <span id="raccoon-kills" style="color: #ff4444; font-weight: bold;">0</span></div>
                    <div>Monster HP: <span id="monster-health" style="color: #ff8800; font-weight: bold;">100</span></div>
                    <div>Shots: <span id="shots">0</span></div>
                    <div>Hits: <span id="hits">0</span></div>
                    <div>Accuracy: <span id="accuracy">0%</span></div>
                </div>

                <div id="click-to-play" class="click-to-play">
                    <h3>üéÆ Click to Start</h3>
                    <p>Click anywhere to enable mouse look</p>
                    <p>Use WASD to move around</p>
                    <p>Left click to shoot</p>
                    <p>Press ESC to release mouse</p>
                </div>
                <div id="help-overlay" class="help-overlay" style="display: none;">
                    <div class="help-modal">
                        <div class="help-header">
                            <h2>üéÆ Game Controls & Help</h2>
                            <p>Master these controls to navigate and dominate the 3D room!</p>
                        </div>
                        <div class="help-content">
                            <div class="help-section">
                                <h3>üö∂ Movement Controls</h3>
                                <ul class="help-controls">
                                    <li><span class="key-combo">W</span> Move Forward</li>
                                    <li><span class="key-combo">S</span> Move Backward</li>
                                    <li><span class="key-combo">A</span> Strafe Left</li>
                                    <li><span class="key-combo">D</span> Strafe Right</li>
                                    <li><span class="key-combo">Mouse</span> Look Around</li>
                                </ul>
                            </div>
                            <div class="help-section">
                                <h3>üî´ Combat Controls</h3>
                                <ul class="help-controls">
                                    <li><span class="key-combo">Click</span> Start Game / Shoot</li>
                                    <li><span class="key-combo">1</span> Switch to Rifle</li>
                                    <li><span class="key-combo">2</span> Switch to Pistol</li>
                                    <li><span class="key-combo">Hold</span> Auto-fire (Rifle)</li>
                                </ul>
                            </div>
                            <div class="help-section">
                                <h3>üéõÔ∏è Game Controls</h3>
                                <ul class="help-controls">
                                    <li><span class="key-combo">ESC</span> Release Mouse Lock</li>
                                    <li><span class="key-combo">H</span> Toggle Help Menu</li>
                                    <li><span class="key-combo">F11</span> Toggle Fullscreen</li>
                                </ul>
                            </div>
                            <div class="help-section">
                                <h3>üéØ Game Features</h3>
                                <ul class="help-controls">
                                    <li><span class="key-combo">üìç</span> Minimap shows position</li>
                                    <li><span class="key-combo">üéØ</span> Crosshair for aiming</li>
                                    <li><span class="key-combo">üí•</span> Muzzle flash effects</li>
                                    <li><span class="key-combo">üëæ</span> Moving enemy targets</li>
                                </ul>
                            </div>
                        </div>
                        <div class="help-footer">
                            <button class="close-btn" onclick="hideHelp()">Got it! Let's Play</button>
                            <p>Press <strong>ESC</strong> or click outside to close this help menu</p>
                        </div>
                    </div>
                </div>

                <!-- World Generation Settings Modal -->
                <div id="worldgen-overlay" class="help-overlay" style="display: none;">
                    <div class="help-modal" style="max-width: 600px;">
                        <div class="help-header">
                            <h2>üåç World Generation Settings</h2>
                            <p>Customize the procedural maze generation</p>
                        </div>
                        <div style="padding: 1rem;">
                            <div style="margin-bottom: 1.5rem; padding: 1rem; background: rgba(var(--accent-rgb), 0.1); border-radius: 8px; border: 1px solid var(--accent-color);">
                                <h3 style="color: var(--accent-color); margin-top: 0;">Seed</h3>
                                <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                                    <input type="text" id="world-seed-input" style="flex: 1; padding: 0.5rem; font-family: monospace; font-size: 14px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--card-background); color: white;">
                                    <button class="control-btn" onclick="copyWorldSeed()" style="padding: 0.5rem 1rem;">Copy</button>
                                    <button class="control-btn" onclick="randomizeWorldSeed()" style="padding: 0.5rem 1rem;">Random</button>
                                </div>
                                <p style="font-size: 12px; margin: 0; opacity: 0.8;">Use the same seed to generate identical worlds</p>
                            </div>

                            <div style="margin-bottom: 1rem;">
                                <h3 style="color: var(--accent-color);">Wall Generation</h3>
                                <label style="display: block; margin-bottom: 0.5rem;">
                                    Wall Count: <span id="wall-count-value">40</span>
                                    <input type="range" id="wall-count" min="10" max="100" value="40" style="width: 100%;" oninput="document.getElementById('wall-count-value').textContent = this.value">
                                </label>
                                <label style="display: block; margin-bottom: 0.5rem;">
                                    Min Wall Length: <span id="min-wall-value">5</span>
                                    <input type="range" id="min-wall-length" min="3" max="20" value="5" style="width: 100%;" oninput="document.getElementById('min-wall-value').textContent = this.value">
                                </label>
                                <label style="display: block; margin-bottom: 0.5rem;">
                                    Max Wall Length: <span id="max-wall-value">30</span>
                                    <input type="range" id="max-wall-length" min="10" max="50" value="30" style="width: 100%;" oninput="document.getElementById('max-wall-value').textContent = this.value">
                                </label>
                            </div>

                            <div style="margin-bottom: 1rem;">
                                <h3 style="color: var(--accent-color);">Obstacle Generation</h3>
                                <label style="display: block; margin-bottom: 0.5rem;">
                                    Obstacle Count: <span id="obstacle-count-value">10</span>
                                    <input type="range" id="obstacle-count" min="0" max="50" value="10" style="width: 100%;" oninput="document.getElementById('obstacle-count-value').textContent = this.value">
                                </label>
                                <label style="display: block; margin-bottom: 0.5rem;">
                                    Min Obstacle Size: <span id="min-obstacle-value">1</span>
                                    <input type="range" id="min-obstacle-size" min="0.5" max="3" step="0.5" value="1" style="width: 100%;" oninput="document.getElementById('min-obstacle-value').textContent = this.value">
                                </label>
                                <label style="display: block; margin-bottom: 0.5rem;">
                                    Max Obstacle Size: <span id="max-obstacle-value">4</span>
                                    <input type="range" id="max-obstacle-size" min="2" max="8" step="0.5" value="4" style="width: 100%;" oninput="document.getElementById('max-obstacle-value').textContent = this.value">
                                </label>
                            </div>
                        </div>
                        <div class="help-footer">
                            <button class="close-btn" onclick="applyWorldGenSettings()" style="margin-right: 0.5rem;">Apply & Regenerate</button>
                            <button class="control-btn" onclick="hideWorldGen()">Cancel</button>
                        </div>
                    </div>
                </div>

                <div class="crosshair" id="crosshair"></div>
                <div class="pistol-2d" id="weapon-display">
                    <!-- Pistol -->
                    <img src="pistol.png" alt="Pistol" class="weapon-image" id="pistol-image" style="display: block;" onerror="this.style.display='none'; document.getElementById('pistol-fallback').style.display='block';">
                    <div id="pistol-fallback" style="display: none; width: 100%; height: 100%; background: linear-gradient(45deg, #333, #666); border-radius: 10px; position: relative;">
                        <div style="position: absolute; bottom: 20px; right: 50px; width: 200px; height: 80px; background: #222; border-radius: 5px;"></div>
                        <div style="position: absolute; bottom: 40px; right: 250px; width: 80px; height: 12px; background: #111; border-radius: 0 6px 6px 0;"></div>
                    </div>

                    <!-- Automatic Rifle -->
                    <img src="rifle.png" alt="Rifle" class="weapon-image" id="rifle-image" style="display: none;" onerror="this.style.display='none'; document.getElementById('rifle-fallback').style.display='block';">
                    <div id="rifle-fallback" style="display: none; width: 100%; height: 100%; position: relative;">
                        <!-- Simple rifle fallback design -->
                        <div style="position: absolute; bottom: 60px; right: 100px; width: 400px; height: 60px; background: #333; border-radius: 3px;"></div>
                        <div style="position: absolute; bottom: 80px; right: 500px; width: 120px; height: 20px; background: #222; border-radius: 0 10px 10px 0;"></div>
                        <div style="position: absolute; bottom: 40px; right: 150px; width: 80px; height: 40px; background: #444; border-radius: 5px;"></div>
                        <div style="position: absolute; bottom: 20px; right: 80px; color: white; font-family: monospace; font-size: 12px;">Save rifle image as 'rifle.png'</div>
                    </div>
                </div>
                <canvas id="minimap" class="minimap"></canvas>
            </div>

            <div class="controls">
                <button class="control-btn" id="new-maze">Reset Room</button>
                <button class="control-btn" id="worldgen-btn">World Generation</button>
                <button class="control-btn" id="toggle-minimap">Toggle Minimap</button>
                <button class="control-btn" id="reset-position">Reset Position</button>
                <button class="control-btn" id="toggle-fog">Toggle Fog</button>
                <button class="control-btn" id="fullscreen-btn">Fullscreen</button>
                <button class="control-btn" id="help-btn">? Help</button>
                <button class="control-btn" id="cicd-btn">CI/CD Tests</button>
            </div>

            <!-- CI/CD Test Panel -->
            <div id="cicd-overlay" class="cicd-overlay" style="display: none;">
                <div class="cicd-modal">
                    <div class="cicd-header">
                        <h2>üîß CI/CD Test Suite</h2>
                        <p>Validate game functionality before deployment</p>
                    </div>
                    <div class="cicd-checklist">
                        <div class="cicd-test-item">
                            <div class="cicd-test-status pending" id="test-shooting-status"></div>
                            <div class="cicd-test-name">Shooting Mechanics</div>
                        </div>
                        <div class="cicd-test-item">
                            <div class="cicd-test-status pending" id="test-multiplayer-status"></div>
                            <div class="cicd-test-name">Multiplayer System</div>
                        </div>
                        <div class="cicd-test-item">
                            <div class="cicd-test-status pending" id="test-pvp-status"></div>
                            <div class="cicd-test-name">PvP Combat (HP System)</div>
                        </div>
                        <div class="cicd-test-item">
                            <div class="cicd-test-status pending" id="test-enemy-status"></div>
                            <div class="cicd-test-name">Single Enemy (PvE)</div>
                        </div>
                        <div class="cicd-test-item">
                            <div class="cicd-test-status pending" id="test-3d-status"></div>
                            <div class="cicd-test-name">3D Mechanics</div>
                        </div>
                        <div class="cicd-test-item">
                            <div class="cicd-test-status pending" id="test-spike-status"></div>
                            <div class="cicd-test-name">Spike System (Valorant)</div>
                        </div>
                    </div>
                    <div id="cicd-results" class="cicd-results">
                        <div id="cicd-results-message"></div>
                        <div id="cicd-results-details" class="cicd-results-details"></div>
                    </div>
                    <div class="cicd-footer">
                        <button class="run-test-btn" id="run-tests-btn">Run Tests</button>
                        <button class="close-btn" onclick="hideCICDPanel()">Close</button>
                        <p style="margin-top: 1rem; font-size: 12px; color: #888;">Play the game first, then run tests to validate functionality</p>
                    </div>
                </div>
            </div>

            <div class="demo-info">
                <h3>3D Room Explorer</h3>
                <p>Walk around in a simple 3D room with first-person controls and a crosshair!</p>

                <div class="instructions">
                    <div class="instruction-group">
                        <h4>üéÆ Movement Controls</h4>
                        <p><strong>W/A/S/D:</strong> Move forward/left/backward/right</p>
                        <p><strong>Mouse:</strong> Look around (click to enable)</p>
                        <p><strong>Left Click:</strong> Shoot pistol</p>
                        <p><strong>ESC:</strong> Release mouse cursor</p>
                    </div>
                    <div class="instruction-group">
                        <h4>üî´ Shooting</h4>
                        <p><strong>2D Pistol:</strong> CSS-based gun in bottom-right</p>
                        <p><strong>Muzzle Flash:</strong> Yellow flash when shooting</p>
                        <p><strong>Recoil:</strong> Gun kicks back when fired</p>
                        <p><strong>No Target:</strong> Just shoot for fun!</p>
                    </div>
                    <div class="instruction-group">
                        <h4>üéØ Features</h4>
                        <p><strong>Crosshair:</strong> White crosshair for aiming</p>
                        <p><strong>Minimap:</strong> Shows position and direction</p>
                        <p><strong>Collision:</strong> Can't walk through walls</p>
                        <p><strong>First-Person:</strong> Natural FPS-style controls</p>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2024 John Doe. All rights reserved.</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.socket.io/4.7.0/socket.io.min.js"></script>
    <script src="script.js"></script>
    <script src="multiplayer-client.js"></script>
    <script>
        // 3D Room Game Variables
        let scene, camera, renderer, raycaster;
        let roomGroup, enemies = [];
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let wallHeight = 3;
        let minimapVisible = true;
        let fogEnabled = true;
        let playerLight; // Flashlight attached to player
        let raccoonChasers = []; // Array of horror nextbots chasing the player
        let totalKillCount = 0; // Total kills across all raccoons

        // Shooting variables
        let shotsFired = 0;
        let shotsHit = 0;

        // Player health (PvP system)
        let playerHealth = 100;
        const maxPlayerHealth = 100;

        // Weapon system
        let currentWeapon = 'pistol'; // 'pistol' or 'rifle'
        let isAutoFiring = false;
        let autoFireInterval = null;
        let recoilAccumulation = { x: 0, y: 0 };
        let recoilRecoveryTimer = null;

        // Enemy variables
        let enemyCount = 0; // No dummy enemies, only the raccoon chaser!
        let enemySpeed = 0.02; // Increased speed for more visible movement

        // Multiplayer variables
        let networkPlayers = new Map(); // Store network player meshes
        let isMultiplayer = false;
        let playerName = null;
        let multiplayerClient = null;
        let isHost = false;

        // Camera controls
        let yaw = 0; // Horizontal rotation
        let pitch = 0; // Vertical rotation
        const maxPitch = Math.PI / 3; // Limit looking up/down

        // Jump mechanics
        let isJumping = false;
        let verticalVelocity = 0;
        const jumpStrength = 0.15;
        const gravity = 0.008;
        const groundLevel = 1.6; // Camera height when on ground

        // Procedural generation parameters
        let worldSeed = Math.floor(Math.random() * 1000000);
        let generationParams = {
            roomSize: 100,
            wallCount: 40,
            minWallLength: 5,
            maxWallLength: 30,
            obstacleCount: 10,
            minObstacleSize: 1,
            maxObstacleSize: 4
        };


        // Sound effects (using Web Audio API)
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playShootSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);

            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        function playJumpSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(500, audioContext.currentTime + 0.15);

            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.15);
        }

        function playHitSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.2);

            gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.2);
        }


        // Seeded random number generator
        class SeededRandom {
            constructor(seed) {
                this.seed = seed;
            }

            random() {
                const x = Math.sin(this.seed++) * 10000;
                return x - Math.floor(x);
            }

            randomRange(min, max) {
                return min + this.random() * (max - min);
            }

            randomInt(min, max) {
                return Math.floor(this.randomRange(min, max + 1));
            }
        }

        // Check if two rectangles overlap (with margin)
        function rectanglesOverlap(rect1, rect2, margin = 0.5) {
            const x1Min = rect1.x - rect1.w / 2 - margin;
            const x1Max = rect1.x + rect1.w / 2 + margin;
            const z1Min = rect1.z - rect1.d / 2 - margin;
            const z1Max = rect1.z + rect1.d / 2 + margin;

            const x2Min = rect2.x - rect2.w / 2 - margin;
            const x2Max = rect2.x + rect2.w / 2 + margin;
            const z2Min = rect2.z - rect2.d / 2 - margin;
            const z2Max = rect2.z + rect2.d / 2 + margin;

            return !(x1Max < x2Min || x1Min > x2Max || z1Max < z2Min || z1Min > z2Max);
        }

        // Generate procedural maze walls with overlap prevention
        function generateProceduralWalls(seed, params) {
            const rng = new SeededRandom(seed);
            const walls = [];
            const roomBound = params.roomSize / 2 - 5;
            const maxAttempts = params.wallCount * 10; // Try up to 10x the wall count
            let attempts = 0;

            // Generate random walls without overlaps
            while (walls.length < params.wallCount && attempts < maxAttempts) {
                attempts++;

                const isHorizontal = rng.random() > 0.5;
                const length = rng.randomRange(params.minWallLength, params.maxWallLength);
                const thickness = 1;

                const x = rng.randomRange(-roomBound, roomBound);
                const z = rng.randomRange(-roomBound, roomBound);

                const newWall = isHorizontal
                    ? { x, z, w: length, h: wallHeight, d: thickness }
                    : { x, z, w: thickness, h: wallHeight, d: length };

                // Check if this wall overlaps with any existing wall
                let overlaps = false;
                for (const existingWall of walls) {
                    if (rectanglesOverlap(newWall, existingWall)) {
                        overlaps = true;
                        break;
                    }
                }

                // Only add the wall if it doesn't overlap
                if (!overlaps) {
                    walls.push(newWall);
                }
            }

            console.log(`Generated ${walls.length} non-overlapping walls (attempted ${attempts} times)`);
            return walls;
        }

        // Generate procedural obstacles with overlap prevention
        function generateProceduralObstacles(seed, params, existingWalls = []) {
            const rng = new SeededRandom(seed + 999999); // Different seed offset for obstacles
            const obstacles = [];
            const roomBound = params.roomSize / 2 - 10;
            const maxAttempts = params.obstacleCount * 10;
            let attempts = 0;

            while (obstacles.length < params.obstacleCount && attempts < maxAttempts) {
                attempts++;

                const width = rng.randomRange(params.minObstacleSize, params.maxObstacleSize);
                const depth = rng.randomRange(params.minObstacleSize, params.maxObstacleSize);
                const height = rng.randomRange(0.5, 2);

                const x = rng.randomRange(-roomBound, roomBound);
                const z = rng.randomRange(-roomBound, roomBound);

                // Avoid spawning near player start (0, 0)
                if (Math.abs(x) < 5 && Math.abs(z) < 5) continue;

                const newObstacle = { x, z, w: width, h: height, d: depth, width, depth, height };

                // Check if this obstacle overlaps with any existing wall
                let overlaps = false;
                for (const wall of existingWalls) {
                    if (rectanglesOverlap(newObstacle, wall)) {
                        overlaps = true;
                        break;
                    }
                }

                // Check if this obstacle overlaps with any existing obstacle
                if (!overlaps) {
                    for (const existingObstacle of obstacles) {
                        if (rectanglesOverlap(newObstacle, existingObstacle)) {
                            overlaps = true;
                            break;
                        }
                    }
                }

                // Only add the obstacle if it doesn't overlap
                if (!overlaps) {
                    obstacles.push({ x, z, width, depth, height });
                }
            }

            console.log(`Generated ${obstacles.length} non-overlapping obstacles (attempted ${attempts} times)`);
            return obstacles;
        }

        // Create a simple room with four walls
        function createRoom() {
            try {
                console.log('Creating room...');

                if (roomGroup) {
                    scene.remove(roomGroup);
                }

                roomGroup = new THREE.Group();

            // Room dimensions - MUCH BIGGER MAZE for horror experience
            const roomSize = 100;
            const wallThickness = 1;

            // Create wall texture
            const wallCanvas = document.createElement('canvas');
            const wallCtx = wallCanvas.getContext('2d');
            wallCanvas.width = 256;
            wallCanvas.height = 256;

            // Create darker brick pattern for horror atmosphere
            wallCtx.fillStyle = '#2a1810'; // Much darker brown
            wallCtx.fillRect(0, 0, 256, 256);

            // Draw brick lines
            wallCtx.strokeStyle = '#1a0a05'; // Nearly black
            wallCtx.lineWidth = 2;
            for (let i = 0; i < 256; i += 32) {
                wallCtx.beginPath();
                wallCtx.moveTo(0, i);
                wallCtx.lineTo(256, i);
                wallCtx.stroke();

                // Offset every other row
                const offset = (Math.floor(i / 32) % 2) * 16;
                for (let j = offset; j < 256; j += 32) {
                    wallCtx.beginPath();
                    wallCtx.moveTo(j, i);
                    wallCtx.lineTo(j, i + 32);
                    wallCtx.stroke();
                }
            }

            const wallTexture = new THREE.CanvasTexture(wallCanvas);
            wallTexture.wrapS = THREE.RepeatWrapping;
            wallTexture.wrapT = THREE.RepeatWrapping;

            const wallMaterial = new THREE.MeshPhongMaterial({
                map: wallTexture,
                shininess: 10
            });

            // Create floor texture
            const floorCanvas = document.createElement('canvas');
            const floorCtx = floorCanvas.getContext('2d');
            floorCanvas.width = 256;
            floorCanvas.height = 256;

            // Create darker tile pattern for horror
            floorCtx.fillStyle = '#0f0f0f'; // Nearly black floor
            floorCtx.fillRect(0, 0, 256, 256);

            // Draw tile lines
            floorCtx.strokeStyle = '#050505'; // Pure black lines
            floorCtx.lineWidth = 1;
            for (let i = 0; i < 256; i += 64) {
                floorCtx.beginPath();
                floorCtx.moveTo(0, i);
                floorCtx.lineTo(256, i);
                floorCtx.stroke();

                floorCtx.beginPath();
                floorCtx.moveTo(i, 0);
                floorCtx.lineTo(i, 256);
                floorCtx.stroke();
            }

            const floorTexture = new THREE.CanvasTexture(floorCanvas);
            floorTexture.wrapS = THREE.RepeatWrapping;
            floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.repeat.set(10, 10);

            const floorMaterial = new THREE.MeshPhongMaterial({
                map: floorTexture,
                shininess: 5
            });


            // Create floor
            const floorGeometry = new THREE.PlaneGeometry(roomSize, roomSize);
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(0, 0, 0);
            floor.receiveShadow = true;
            roomGroup.add(floor);

            // Create four walls with proper thickness to prevent see-through
            // North wall
            const northWall = new THREE.Mesh(
                new THREE.BoxGeometry(roomSize + 2, wallHeight, wallThickness * 2),
                wallMaterial
            );
            northWall.position.set(0, wallHeight / 2, -roomSize / 2);
            northWall.castShadow = true;
            northWall.receiveShadow = true;
            roomGroup.add(northWall);

            // South wall
            const southWall = new THREE.Mesh(
                new THREE.BoxGeometry(roomSize + 2, wallHeight, wallThickness * 2),
                wallMaterial
            );
            southWall.position.set(0, wallHeight / 2, roomSize / 2);
            southWall.castShadow = true;
            southWall.receiveShadow = true;
            roomGroup.add(southWall);

            // East wall
            const eastWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness * 2, wallHeight, roomSize + 2),
                wallMaterial
            );
            eastWall.position.set(roomSize / 2, wallHeight / 2, 0);
            eastWall.castShadow = true;
            eastWall.receiveShadow = true;
            roomGroup.add(eastWall);

            // West wall
            const westWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness * 2, wallHeight, roomSize + 2),
                wallMaterial
            );
            westWall.position.set(-roomSize / 2, wallHeight / 2, 0);
            westWall.castShadow = true;
            westWall.receiveShadow = true;
            roomGroup.add(westWall);

            // Create cover material with texture
            const coverCanvas = document.createElement('canvas');
            const coverCtx = coverCanvas.getContext('2d');
            coverCanvas.width = 128;
            coverCanvas.height = 128;

            // Create metal texture
            coverCtx.fillStyle = '#696969';
            coverCtx.fillRect(0, 0, 128, 128);

            // Add metal lines
            coverCtx.strokeStyle = '#505050';
            coverCtx.lineWidth = 1;
            for (let i = 0; i < 128; i += 16) {
                coverCtx.beginPath();
                coverCtx.moveTo(0, i);
                coverCtx.lineTo(128, i);
                coverCtx.stroke();
            }

            const coverTexture = new THREE.CanvasTexture(coverCanvas);
            const coverMaterial = new THREE.MeshPhongMaterial({
                map: coverTexture,
                shininess: 20
            });

            // Cover box 1 - left side
            const coverBox1 = new THREE.Mesh(
                new THREE.BoxGeometry(2, 1.5, 2),
                coverMaterial
            );
            coverBox1.position.set(-6, 0.75, -3);
            coverBox1.castShadow = true;
            coverBox1.receiveShadow = true;
            roomGroup.add(coverBox1);

            // Cover box 2 - right side
            const coverBox2 = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 1.2, 1.5),
                coverMaterial
            );
            coverBox2.position.set(5, 0.6, -5);
            coverBox2.castShadow = true;
            coverBox2.receiveShadow = true;
            roomGroup.add(coverBox2);

            // Cover wall - partial wall in middle
            const coverWall = new THREE.Mesh(
                new THREE.BoxGeometry(4, 2, 0.5),
                wallMaterial
            );
            coverWall.position.set(3, 1, 2);
            coverWall.castShadow = true;
            coverWall.receiveShadow = true;
            roomGroup.add(coverWall);

            // Cover box 3 - near player spawn
            const coverBox3 = new THREE.Mesh(
                new THREE.BoxGeometry(1, 0.8, 3),
                coverMaterial
            );
            coverBox3.position.set(-3, 0.4, 5);
            coverBox3.castShadow = true;
            coverBox3.receiveShadow = true;
            roomGroup.add(coverBox3);

            // Add more walls for complex layout
            // Additional wall 1 - L-shaped corner
            const additionalWall1 = new THREE.Mesh(
                new THREE.BoxGeometry(6, wallHeight, wallThickness),
                wallMaterial
            );
            additionalWall1.position.set(-2, wallHeight / 2, -6);
            additionalWall1.castShadow = true;
            additionalWall1.receiveShadow = true;
            roomGroup.add(additionalWall1);

            // Additional wall 2 - vertical connector
            const additionalWall2 = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, 4),
                wallMaterial
            );
            additionalWall2.position.set(1, wallHeight / 2, -4);
            additionalWall2.castShadow = true;
            additionalWall2.receiveShadow = true;
            roomGroup.add(additionalWall2);

            // Additional wall 3 - room divider
            const additionalWall3 = new THREE.Mesh(
                new THREE.BoxGeometry(8, wallHeight, wallThickness),
                wallMaterial
            );
            additionalWall3.position.set(-4, wallHeight / 2, 3);
            additionalWall3.castShadow = true;
            additionalWall3.receiveShadow = true;
            roomGroup.add(additionalWall3);

            // Additional wall 4 - corner piece
            const additionalWall4 = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, 5),
                wallMaterial
            );
            additionalWall4.position.set(7, wallHeight / 2, 6);
            additionalWall4.castShadow = true;
            additionalWall4.receiveShadow = true;
            roomGroup.add(additionalWall4);

            // PROCEDURALLY GENERATE MAZE WALLS
            const mazeWalls = generateProceduralWalls(worldSeed, generationParams);
            console.log(`Generated ${mazeWalls.length} procedural walls with seed ${worldSeed}`);

            mazeWalls.forEach((wallSpec, idx) => {
                const mazeWall = new THREE.Mesh(
                    new THREE.BoxGeometry(wallSpec.w, wallSpec.h, wallSpec.d),
                    wallMaterial
                );
                mazeWall.position.set(wallSpec.x, wallSpec.h / 2, wallSpec.z);
                mazeWall.castShadow = true;
                mazeWall.receiveShadow = true;
                roomGroup.add(mazeWall);
            });

            // PROCEDURALLY GENERATE OBSTACLES (pass walls to prevent overlap)
            const proceduralObstacles = generateProceduralObstacles(worldSeed, generationParams, mazeWalls);
            console.log(`Generated ${proceduralObstacles.length} procedural obstacles`);

            // Create obstacle material
            const obstacleMaterial = new THREE.MeshPhongMaterial({
                color: 0x4a3520,
                shininess: 10
            });

            proceduralObstacles.forEach((obsSpec, idx) => {
                const obstacle = new THREE.Mesh(
                    new THREE.BoxGeometry(obsSpec.width, obsSpec.height, obsSpec.depth),
                    obstacleMaterial
                );
                obstacle.position.set(obsSpec.x, obsSpec.height / 2, obsSpec.z);
                obstacle.castShadow = true;
                obstacle.receiveShadow = true;
                roomGroup.add(obstacle);
            });

            // Initialize collidable objects for collision detection
            collidableObjects = generateCollidableObjects(worldSeed, generationParams);
            console.log(`Generated ${collidableObjects.length} total collidable objects`);

            // Create multiple enemies (smaller and taller)
            enemies = [];
            for (let i = 0; i < enemyCount; i++) {
                const enemyGeometry = new THREE.PlaneGeometry(0.6, 1.6); // Same height as player

                // Create texture for enemy
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 96;
                canvas.height = 256;

                // Different colored enemies
                const colors = ['#E74C3C', '#3498DB', '#2ECC71', '#F39C12', '#9B59B6'];
                const color = colors[i % colors.length];

                ctx.fillStyle = color;
                ctx.fillRect(0, 0, 96, 256);
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Enemy ${i + 1}`, 48, 130);

                const texture = new THREE.CanvasTexture(canvas);
                const enemyMaterial = new THREE.MeshPhongMaterial({
                    map: texture,
                    transparent: true,
                    side: THREE.DoubleSide
                });

                const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);

                // Random positions avoiding walls using proper collision detection
                let posX, posZ, attempts = 0;
                do {
                    posX = (Math.random() - 0.5) * 16; // Within room bounds
                    posZ = (Math.random() - 0.5) * 16;
                    attempts++;
                } while (checkCollision({x: posX, z: posZ}) && attempts < 50); // Use collision system

                // Fallback to safe position if can't find spot
                if (attempts >= 50) {
                    posX = 0;
                    posZ = 0;
                }

                enemy.position.set(posX, 0.8, posZ); // Same height as player camera - half
                enemy.castShadow = true;

                // Add movement properties
                enemy.userData = {
                    id: `enemy_${i}`, // Unique ID for multiplayer sync
                    direction: Math.random() * Math.PI * 2, // Random initial direction
                    speed: enemySpeed * (0.8 + Math.random() * 0.7), // Increased speed range
                    changeDirectionTimer: Math.random() * 200, // Random direction change
                    originalColor: enemy.material.color.clone(),
                    alive: true
                };

                console.log(`Enemy ${i + 1} created at (${posX}, ${posZ}) with speed ${enemy.userData.speed}`);

                enemies.push(enemy);
                roomGroup.add(enemy);
            }

            // Function to create a new raccoon
            function createRaccoon(spawnX, spawnZ) {
                try {
                const raccoonGeometry = new THREE.PlaneGeometry(3, 3); // Bigger and scarier (increased from 2x2 to 3x3)

                // Create a bright red fallback canvas texture FIRST
                const fallbackCanvas = document.createElement('canvas');
                fallbackCanvas.width = 256;
                fallbackCanvas.height = 256;
                const fallbackCtx = fallbackCanvas.getContext('2d');

                // Draw a scary red face/silhouette
                fallbackCtx.fillStyle = '#ff0000';
                fallbackCtx.fillRect(0, 0, 256, 256);
                fallbackCtx.fillStyle = '#ffffff';
                fallbackCtx.font = 'bold 120px Arial';
                fallbackCtx.textAlign = 'center';
                fallbackCtx.textBaseline = 'middle';
                fallbackCtx.fillText('üëπ', 128, 128);

                const fallbackTexture = new THREE.CanvasTexture(fallbackCanvas);

                // Use MeshBasicMaterial with fallback texture as default
                const raccoonMaterial = new THREE.MeshBasicMaterial({
                    map: fallbackTexture, // Start with fallback
                    transparent: true,
                    side: THREE.DoubleSide,
                    opacity: 1.0,
                    color: 0xffffff
                });

                const raccoonChaser = new THREE.Mesh(raccoonGeometry, raccoonMaterial);

                // Try to load the raccoon image texture in the background
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(
                    'racooon.png',
                    function(texture) {
                        console.log('Raccoon texture loaded successfully');
                        raccoonChaser.material.map = texture;
                        raccoonChaser.material.needsUpdate = true;
                    },
                    undefined,
                    function(err) {
                        console.log('Using fallback texture for raccoon (image not found)');
                    }
                );

                // Spawn at specified location
                raccoonChaser.position.set(spawnX, 1, spawnZ);
                raccoonChaser.castShadow = false; // Don't cast shadow, we want it glowing

                // Add a VERY bright point light to the raccoon to make it always visible
                const raccoonLight = new THREE.PointLight(0xff4444, 5.0, 25);
                // Increased intensity from 2.0 to 5.0, range from 10 to 25
                raccoonLight.position.set(0, 0, 0);
                raccoonChaser.add(raccoonLight); // Attach light to raccoon so it moves with it

                raccoonChaser.userData = {
                    speed: 0.038, // 5% slower than player (player: 0.04, raccoon: 0.038 - 95% speed)
                    active: true,
                    light: raccoonLight, // Store reference to light
                    health: 100,
                    maxHealth: 100,
                    killCount: 0, // Track how many times raccoon has been defeated
                    baseSpeed: 0.038,
                    baseMaxHealth: 100
                };

                // Create health bar above raccoon
                const healthBarWidth = 3;
                const healthBarHeight = 0.3;
                const healthBarGroup = new THREE.Group();

                // Background (red)
                const healthBgGeometry = new THREE.PlaneGeometry(healthBarWidth, healthBarHeight);
                const healthBgMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
                const healthBg = new THREE.Mesh(healthBgGeometry, healthBgMaterial);
                healthBarGroup.add(healthBg);

                // Foreground (green) - shows current health
                const healthFgGeometry = new THREE.PlaneGeometry(healthBarWidth, healthBarHeight);
                const healthFgMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
                const healthFg = new THREE.Mesh(healthFgGeometry, healthFgMaterial);
                healthFg.position.z = 0.01; // Slightly in front of background
                healthBarGroup.add(healthFg);

                // Position health bar above raccoon
                healthBarGroup.position.y = 2.2; // Above the 3x3 sprite
                raccoonChaser.add(healthBarGroup);

                // Store reference to health bar
                raccoonChaser.userData.healthBar = healthFg;
                raccoonChaser.userData.healthBarGroup = healthBarGroup;

                roomGroup.add(raccoonChaser);
                raccoonChasers.push(raccoonChaser); // Add to array
                console.log('Raccoon chaser created at position:', raccoonChaser.position);
                return raccoonChaser;
                } catch (error) {
                    console.error('Error creating raccoon chaser:', error);
                    return null;
                }
            }

            // Create initial raccoon
            createRaccoon(45, 45);

            scene.add(roomGroup);

            // Reset player position to center
            camera.position.set(0, 1.6, 0);
            yaw = 0;
            pitch = 0;

            console.log('Room created successfully');
            } catch (error) {
                console.error('Error creating room:', error);
            }
        }

        // Define all collidable objects with height information (dynamically generated)
        let collidableObjects = [];

        // Generate collidable objects from procedural data
        function generateCollidableObjects(seed, params) {
            const objects = [];

            // Generate static cover boxes
            objects.push(
                { x: -6, z: -3, width: 2, depth: 2, height: 1.5, topY: 0.75 },
                { x: 5, z: -5, width: 1.5, depth: 1.5, height: 1.2, topY: 0.6 },
                { x: 3, z: 2, width: 4, depth: 0.5, height: 2, topY: 1 },
                { x: -3, z: 5, width: 1, depth: 3, height: 0.8, topY: 0.4 }
            );

            // Generate static additional walls
            objects.push(
                { x: -2, z: -6, width: 6, depth: 1, height: 3, topY: 1.5 },
                { x: 1, z: -4, width: 1, depth: 4, height: 3, topY: 1.5 },
                { x: -4, z: 3, width: 8, depth: 1, height: 3, topY: 1.5 },
                { x: 7, z: 6, width: 1, depth: 5, height: 3, topY: 1.5 }
            );

            // Add procedural maze walls
            const mazeWalls = generateProceduralWalls(seed, params);
            mazeWalls.forEach(wall => {
                objects.push({
                    x: wall.x,
                    z: wall.z,
                    width: wall.w,
                    depth: wall.d,
                    height: wall.h,
                    topY: wall.h / 2
                });
            });

            // Add procedural obstacles (pass walls to prevent overlap)
            const obstacles = generateProceduralObstacles(seed, params, mazeWalls);
            obstacles.forEach(obs => {
                objects.push({
                    x: obs.x,
                    z: obs.z,
                    width: obs.width,
                    depth: obs.depth,
                    height: obs.height,
                    topY: obs.height / 2
                });
            });

            return objects;
        }

        function checkCollision(newPosition, currentHeight = camera.position.y) {
            const margin = 0.4; // Reduced margin for better gap navigation
            const roomBounds = 48.5; // Updated for 100-unit room (was 8.8 for 20-unit room)

            // Check room boundary collision with proper wall thickness
            if (Math.abs(newPosition.x) > roomBounds || Math.abs(newPosition.z) > roomBounds) {
                return true;
            }

            // Check collision with all interior walls and cover objects
            // Only block if object is taller than player's current height
            for (const obj of collidableObjects) {
                const halfWidth = obj.width / 2 + margin;
                const halfDepth = obj.depth / 2 + margin;

                if (newPosition.x >= obj.x - halfWidth &&
                    newPosition.x <= obj.x + halfWidth &&
                    newPosition.z >= obj.z - halfDepth &&
                    newPosition.z <= obj.z + halfDepth) {

                    // Allow walking on top of short objects (cover boxes)
                    // Block only if object is taller than camera or if camera is below object top
                    const objectTopHeight = obj.topY + groundLevel;
                    const playerHeight = currentHeight;

                    // If player is above the object, allow movement
                    if (playerHeight >= objectTopHeight - 0.2) {
                        // Player is on top or high enough, don't block
                        continue;
                    }

                    // Block collision for tall walls and when player is below object
                    if (obj.height >= 2.0 || playerHeight < objectTopHeight - 0.2) {
                        return true;
                    }
                }
            }

            // Check collision with living enemies
            for (const enemy of enemies) {
                if (enemy.userData.alive) {
                    const enemyMargin = 0.5;
                    const distance = Math.sqrt(
                        Math.pow(newPosition.x - enemy.position.x, 2) +
                        Math.pow(newPosition.z - enemy.position.z, 2)
                    );
                    if (distance < enemyMargin) {
                        return true;
                    }
                }
            }

            return false;
        }

        function getGroundLevelAt(x, z) {
            const margin = 0.3; // Smaller margin for standing on objects
            let maxHeight = 0; // Floor level

            // Check each collidable object
            for (const obj of collidableObjects) {
                const halfWidth = obj.width / 2 + margin;
                const halfDepth = obj.depth / 2 + margin;

                // Check if player is standing on this object
                if (x >= obj.x - halfWidth &&
                    x <= obj.x + halfWidth &&
                    z >= obj.z - halfDepth &&
                    z <= obj.z + halfDepth) {
                    // Player is above this object
                    maxHeight = Math.max(maxHeight, obj.topY);
                }
            }

            return maxHeight;
        }

        function shoot() {
            shotsFired++;
            console.log('Shot fired! Total shots:', shotsFired);

            // Play shooting sound
            playShootSound();

            // Send multiplayer shoot event
            if (isMultiplayer && multiplayerClient && multiplayerClient.isMultiplayerActive()) {
                multiplayerClient.sendShootEvent(
                    camera.position,
                    { yaw: yaw, pitch: pitch },
                    currentWeapon
                );
            }

            // Get weapon element
            const weapon = document.getElementById('weapon-display');

            // Apply recoil based on weapon type
            if (currentWeapon === 'rifle') {
                // Accumulate recoil for spray pattern
                recoilAccumulation.x += (Math.random() - 0.5) * 0.8;
                recoilAccumulation.y += Math.random() * 0.6;

                // Limit maximum recoil
                recoilAccumulation.x = Math.max(-5, Math.min(5, recoilAccumulation.x));
                recoilAccumulation.y = Math.max(0, Math.min(8, recoilAccumulation.y));

                // Apply recoil to camera
                pitch += recoilAccumulation.y * 0.005;
                yaw += recoilAccumulation.x * 0.003;

                // Clamp pitch
                pitch = Math.max(-maxPitch, Math.min(maxPitch, pitch));

                // Start recoil recovery
                if (recoilRecoveryTimer) clearTimeout(recoilRecoveryTimer);
                recoilRecoveryTimer = setTimeout(() => {
                    const recoveryInterval = setInterval(() => {
                        recoilAccumulation.x *= 0.9;
                        recoilAccumulation.y *= 0.9;

                        if (Math.abs(recoilAccumulation.x) < 0.1 && Math.abs(recoilAccumulation.y) < 0.1) {
                            recoilAccumulation = { x: 0, y: 0 };
                            clearInterval(recoveryInterval);
                        }
                    }, 50);
                }, 200);
            }

            // Check for hit using raycaster against enemies AND network players
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            // Collect all shootable targets
            const livingEnemies = enemies.filter(enemy => enemy.userData.alive);
            const networkPlayerMeshes = Array.from(networkPlayers.values())
                .map(player => player.mesh)
                .filter(mesh => mesh !== null && mesh !== undefined);

            // Add all raccoons to shootable targets
            const shootableTargets = [...livingEnemies, ...networkPlayerMeshes];
            raccoonChasers.forEach(raccoon => {
                if (raccoon && raccoon.userData.active && raccoon.userData.health > 0) {
                    shootableTargets.push(raccoon);
                }
            });

            const allTargets = shootableTargets;
            const intersects = raycaster.intersectObjects(allTargets, false);

            let isHit = false;
            if (intersects.length > 0) {
                const hitObject = intersects[0].object;

                // Check if hit any raccoon
                const hitRaccoon = raccoonChasers.find(r => r === hitObject);
                if (hitRaccoon) {
                    shotsHit++;
                    isHit = true;

                    // Determine damage based on weapon
                    const damage = currentWeapon === 'rifle' ? 15 : 25; // Rifle does less damage per shot, pistol more
                    hitRaccoon.userData.health -= damage;

                    console.log(`Raccoon hit! Damage: ${damage}, Health: ${hitRaccoon.userData.health}/${hitRaccoon.userData.maxHealth}`);

                    // Play hit sound
                    playHitSound();

                    // Flash effect on raccoon
                    const originalColor = hitRaccoon.material.color.clone();
                    hitRaccoon.material.color.setRGB(1, 1, 1); // Flash white
                    setTimeout(() => {
                        if (hitRaccoon && hitRaccoon.material) {
                            hitRaccoon.material.color.copy(originalColor);
                        }
                    }, 100);
                }
                // Check if hit an enemy
                else if (livingEnemies.includes(hitObject)) {
                    const hitEnemy = hitObject;
                    shotsHit++;
                    isHit = true;
                    console.log('Enemy hit! Total hits:', shotsHit);

                    // Mark enemy as dead and start fall animation
                    hitEnemy.userData.alive = false;
                    hitEnemy.material.color.setRGB(0.3, 0.3, 0.3); // Grey out dead enemy
                    hitEnemy.material.opacity = 0.7;

                    // Fall over animation
                    const fallDuration = 800;
                    const startRotation = hitEnemy.rotation.x;
                    const startTime = Date.now();

                    const animateFall = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / fallDuration, 1);

                        // Ease out animation
                        const easeOut = 1 - Math.pow(1 - progress, 3);

                        hitEnemy.rotation.x = startRotation + (Math.PI / 2) * easeOut;
                        hitEnemy.position.y = 0.8 * (1 - easeOut * 0.9); // Fall down

                        if (progress < 1) {
                            requestAnimationFrame(animateFall);
                        } else {
                            // Remove from scene after fall
                            setTimeout(() => {
                                roomGroup.remove(hitEnemy);
                                const index = enemies.indexOf(hitEnemy);
                                if (index > -1) enemies.splice(index, 1);
                            }, 2000);
                        }
                    };
                    animateFall();
                }
                // Check if hit a network player
                else if (networkPlayerMeshes.includes(hitObject)) {
                    shotsHit++;
                    isHit = true;

                    // Find which player was hit
                    const hitPlayer = Array.from(networkPlayers.values())
                        .find(p => p.mesh === hitObject);

                    if (hitPlayer && isMultiplayer && multiplayerClient) {
                        console.log(`Hit player: ${hitPlayer.name}`);

                        // Send player hit event to server
                        multiplayerClient.socket.emit('playerHit', {
                            targetPlayerId: hitPlayer.id,
                            damage: 40,
                            shooterPosition: camera.position
                        });
                    }
                }
            }

            // Create bullet path visualization
            createBulletPath(isHit);

            // Trigger weapon recoil animation
            const recoilDuration = currentWeapon === 'rifle' ? '0.1s' : '0.2s';
            weapon.style.animation = `recoil ${recoilDuration} ease-out`;

            // Reset animations after they complete
            setTimeout(() => {
                weapon.style.animation = '';
            }, currentWeapon === 'rifle' ? 100 : 200);
        }

        function createBulletPath(isHit) {
            // Create bullet path line element
            const path = document.createElement('div');
            path.className = 'bullet-path';

            const container = document.getElementById('canvas-container');
            const containerRect = container.getBoundingClientRect();

            // Calculate path from crosshair center (reverted to original)
            const centerX = containerRect.width / 2;
            const centerY = containerRect.height / 2;

            // Position the path line at crosshair center
            path.style.left = (centerX - 1) + 'px'; // Center the 2px wide line
            path.style.top = centerY + 'px';

            // Calculate path length based on hit or screen bounds
            let pathLength;
            if (isHit) {
                // Calculate distance to target on screen (approximate)
                pathLength = containerRect.height * 0.3; // Target is roughly 30% up from center
            } else {
                // Full screen distance
                pathLength = containerRect.height * 0.8;
            }

            // Set the path direction and length (reverted to simple straight line)
            path.style.height = pathLength + 'px';
            path.style.transform = 'rotate(-15deg)'; // Simple upward angle

            // Add path to container
            container.appendChild(path);

            // Start animation
            path.style.animation = 'bulletPath 0.3s ease-out forwards';

            // Remove path after animation
            setTimeout(() => {
                if (path.parentNode) {
                    path.parentNode.removeChild(path);
                }
            }, 300);
        }


        function updateMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            canvas.width = 200;
            canvas.height = 200;

            if (!minimapVisible) {
                ctx.clearRect(0, 0, 200, 200);
                return;
            }

            const roomSize = 100; // Updated for larger maze (was 20)
            const scale = 200 / roomSize;
            const centerOffset = 100; // Center the room in the minimap

            // Clear canvas
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, 200, 200);

            // Draw room floor
            ctx.fillStyle = '#2F4F2F';
            ctx.fillRect(
                centerOffset - (roomSize / 2) * scale,
                centerOffset - (roomSize / 2) * scale,
                roomSize * scale,
                roomSize * scale
            );

            // Draw outer walls
            ctx.fillStyle = '#8B4513';
            const wallThickness = 3;

            // North wall
            ctx.fillRect(centerOffset - (roomSize / 2) * scale, centerOffset - (roomSize / 2) * scale, roomSize * scale, wallThickness);
            // South wall
            ctx.fillRect(centerOffset - (roomSize / 2) * scale, centerOffset + (roomSize / 2) * scale - wallThickness, roomSize * scale, wallThickness);
            // West wall
            ctx.fillRect(centerOffset - (roomSize / 2) * scale, centerOffset - (roomSize / 2) * scale, wallThickness, roomSize * scale);
            // East wall
            ctx.fillRect(centerOffset + (roomSize / 2) * scale - wallThickness, centerOffset - (roomSize / 2) * scale, wallThickness, roomSize * scale);

            // Draw interior walls and obstacles
            ctx.fillStyle = '#654321'; // Slightly different color for interior walls
            collidableObjects.forEach(obj => {
                const x = centerOffset + (obj.x - obj.width / 2) * scale;
                const z = centerOffset + (obj.z - obj.depth / 2) * scale;
                const w = obj.width * scale;
                const d = obj.depth * scale;

                // Draw walls/obstacles as rectangles
                ctx.fillRect(x, z, w, d);

                // Add border for better visibility
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 0.5;
                ctx.strokeRect(x, z, w, d);
            });

            // Raccoons are NOT shown on minimap - adds to the horror!

            // Draw player
            ctx.fillStyle = '#0080FF';
            ctx.beginPath();
            ctx.arc(
                centerOffset + camera.position.x * scale,
                centerOffset + camera.position.z * scale,
                4,
                0,
                2 * Math.PI
            );
            ctx.fill();

            // Draw player direction indicator
            ctx.strokeStyle = '#0080FF';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(
                centerOffset + camera.position.x * scale,
                centerOffset + camera.position.z * scale
            );
            ctx.lineTo(
                centerOffset + camera.position.x * scale - Math.sin(yaw) * 12,
                centerOffset + camera.position.z * scale - Math.cos(yaw) * 12
            );
            ctx.stroke();
        }

        function takeDamage(damage) {
            playerHealth -= damage;
            if (playerHealth < 0) playerHealth = 0;

            console.log(`Took ${damage} damage! Health: ${playerHealth}`);

            // Play hit sound
            playHitSound();

            // Visual feedback - flash red
            const healthElement = document.getElementById('player-health');
            healthElement.style.textShadow = '0 0 10px #ef4444';
            setTimeout(() => {
                healthElement.style.textShadow = 'none';
            }, 200);
        }

        function updateUI() {
            const posX = Math.floor(camera.position.x);
            const posZ = Math.floor(camera.position.z);
            document.getElementById('position').textContent = `${posX}, ${posZ}`;

            // Update health with color coding
            const healthElement = document.getElementById('player-health');
            healthElement.textContent = playerHealth;
            if (playerHealth > 60) {
                healthElement.style.color = '#22c55e'; // Green
            } else if (playerHealth > 30) {
                healthElement.style.color = '#ffc107'; // Yellow
            } else {
                healthElement.style.color = '#ef4444'; // Red
            }

            // Update raccoon stats
            document.getElementById('raccoon-kills').textContent = totalKillCount;

            // Show combined health of all raccoons
            if (raccoonChasers.length > 0) {
                const totalHealth = raccoonChasers.reduce((sum, r) => sum + Math.max(0, r.userData.health || 0), 0);
                const totalMaxHealth = raccoonChasers.reduce((sum, r) => sum + (r.userData.maxHealth || 0), 0);
                document.getElementById('monster-health').textContent = `${totalHealth}/${totalMaxHealth} (${raccoonChasers.length}x)`;
            }

            // Update shooting stats
            document.getElementById('shots').textContent = shotsFired;
            document.getElementById('hits').textContent = shotsHit;
            const accuracy = shotsFired > 0 ? Math.round((shotsHit / shotsFired) * 100) : 0;
            document.getElementById('accuracy').textContent = accuracy + '%';
        }

        function init() {
            try {
                // Create scene - DARK HORROR ATMOSPHERE
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0a0a0a); // Almost black

                // Add thick dark fog for horror atmosphere
                scene.fog = new THREE.FogExp2(0x000000, 0.05); // Dense exponential fog

                // Create camera
                const container = document.getElementById('canvas-container');
                camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 100);
                camera.position.set(0, 1.6, 0);

                // Create renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(renderer.domElement);

                // Create raycaster for hit detection
                raycaster = new THREE.Raycaster();


                // HORROR GAME LIGHTING - Very dark and ominous
                const ambientLight = new THREE.AmbientLight(0x0a0a15, 0.15); // Extremely dark ambient
                scene.add(ambientLight);

                // Dim moonlight effect
                const directionalLight = new THREE.DirectionalLight(0x1a1a3a, 0.2);
                directionalLight.position.set(15, 25, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 4096;
                directionalLight.shadow.mapSize.height = 4096;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 200;
                directionalLight.shadow.camera.left = -100;
                directionalLight.shadow.camera.right = 100;
                directionalLight.shadow.camera.top = 100;
                directionalLight.shadow.camera.bottom = -100;
                directionalLight.shadow.bias = -0.0001;
                scene.add(directionalLight);

                // Player flashlight - attached to camera (BRIGHTER for better visibility)
                playerLight = new THREE.SpotLight(0xffffdd, 3.5, 50, Math.PI / 5, 0.3, 1.5);
                // Parameters: color, intensity (1.5 -> 3.5), distance (30 -> 50), angle, penumbra, decay
                playerLight.position.set(0, 1.6, 0);
                playerLight.castShadow = true;
                playerLight.shadow.mapSize.width = 2048;
                playerLight.shadow.mapSize.height = 2048;
                scene.add(playerLight);
                scene.add(playerLight.target); // Add target to scene so it can be updated

                // Eerie flickering lights scattered around
                const flickerLight1 = new THREE.PointLight(0x330000, 0.5, 15);
                flickerLight1.position.set(-30, 3, -30);
                scene.add(flickerLight1);

                const flickerLight2 = new THREE.PointLight(0x003300, 0.4, 12);
                flickerLight2.position.set(30, 3, 30);
                scene.add(flickerLight2);

                // Generate initial room
                createRoom();

                // Setup controls
                setupControls();
                setupEventListeners();

                // Handle window resize
                function onWindowResize() {
                    const container = document.getElementById('canvas-container');
                    camera.aspect = container.clientWidth / container.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(container.clientWidth, container.clientHeight);
                }
                window.addEventListener('resize', onWindowResize);

                // Start the animation loop
                animate();

                console.log('3D scene initialized successfully');
            } catch (error) {
                console.error('Error initializing 3D scene:', error);
            }
        }

        function setupControls() {
            document.getElementById('new-maze').addEventListener('click', createRoom);

            document.getElementById('toggle-minimap').addEventListener('click', () => {
                minimapVisible = !minimapVisible;
                document.getElementById('toggle-minimap').textContent =
                    minimapVisible ? 'Hide Minimap' : 'Show Minimap';
            });

            document.getElementById('reset-position').addEventListener('click', () => {
                camera.position.set(0, 1.6, 0);
                yaw = 0;
                pitch = 0;
                camera.rotation.set(0, 0, 0);
            });

            document.getElementById('toggle-fog').addEventListener('click', () => {
                fogEnabled = !fogEnabled;
                scene.fog = fogEnabled ? new THREE.Fog(0x87CEEB, 1, 50) : null;
                document.getElementById('toggle-fog').textContent =
                    fogEnabled ? 'Disable Fog' : 'Enable Fog';
            });

            document.getElementById('fullscreen-btn').addEventListener('click', () => {
                const container = document.getElementById('canvas-container');
                if (!document.fullscreenElement) {
                    container.requestFullscreen().then(() => {
                        document.getElementById('fullscreen-btn').textContent = 'Exit Fullscreen';
                        // Resize renderer to fullscreen
                        camera.aspect = window.innerWidth / window.innerHeight;
                        camera.updateProjectionMatrix();
                        renderer.setSize(window.innerWidth, window.innerHeight);
                    });
                } else {
                    document.exitFullscreen().then(() => {
                        document.getElementById('fullscreen-btn').textContent = 'Fullscreen';
                        // Resize back to container
                        const container = document.getElementById('canvas-container');
                        camera.aspect = container.clientWidth / container.clientHeight;
                        camera.updateProjectionMatrix();
                        renderer.setSize(container.clientWidth, container.clientHeight);
                    });
                }
            });

            document.getElementById('help-btn').addEventListener('click', showHelp);

            // World generation settings button
            document.getElementById('worldgen-btn').addEventListener('click', showWorldGen);

            // Add click-outside-to-close for help overlay
            document.getElementById('help-overlay').addEventListener('click', (e) => {
                if (e.target.id === 'help-overlay') {
                    hideHelp();
                }
            });

            // Add click-outside-to-close for worldgen overlay
            document.getElementById('worldgen-overlay').addEventListener('click', (e) => {
                if (e.target.id === 'worldgen-overlay') {
                    hideWorldGen();
                }
            });

            // CI/CD test panel controls
            document.getElementById('cicd-btn').addEventListener('click', showCICDPanel);
            document.getElementById('run-tests-btn').addEventListener('click', runCICDTests);

            // Add click-outside-to-close for CI/CD overlay
            document.getElementById('cicd-overlay').addEventListener('click', (e) => {
                if (e.target.id === 'cicd-overlay') {
                    hideCICDPanel();
                }
            });
        }

        function showHelp() {
            document.getElementById('help-overlay').style.display = 'flex';
        }

        function hideHelp() {
            document.getElementById('help-overlay').style.display = 'none';
        }

        function toggleHelp() {
            const helpOverlay = document.getElementById('help-overlay');
            if (helpOverlay.style.display === 'flex') {
                hideHelp();
            } else {
                showHelp();
            }
        }

        // World Generation UI functions
        function showWorldGen() {
            // Update UI with current values
            document.getElementById('world-seed-input').value = worldSeed;
            document.getElementById('wall-count').value = generationParams.wallCount;
            document.getElementById('wall-count-value').textContent = generationParams.wallCount;
            document.getElementById('min-wall-length').value = generationParams.minWallLength;
            document.getElementById('min-wall-value').textContent = generationParams.minWallLength;
            document.getElementById('max-wall-length').value = generationParams.maxWallLength;
            document.getElementById('max-wall-value').textContent = generationParams.maxWallLength;
            document.getElementById('obstacle-count').value = generationParams.obstacleCount;
            document.getElementById('obstacle-count-value').textContent = generationParams.obstacleCount;
            document.getElementById('min-obstacle-size').value = generationParams.minObstacleSize;
            document.getElementById('min-obstacle-value').textContent = generationParams.minObstacleSize;
            document.getElementById('max-obstacle-size').value = generationParams.maxObstacleSize;
            document.getElementById('max-obstacle-value').textContent = generationParams.maxObstacleSize;

            document.getElementById('worldgen-overlay').style.display = 'flex';
        }

        function hideWorldGen() {
            document.getElementById('worldgen-overlay').style.display = 'none';
        }

        function copyWorldSeed() {
            const seedInput = document.getElementById('world-seed-input');
            seedInput.select();
            document.execCommand('copy');
            alert(`Seed ${seedInput.value} copied to clipboard!`);
        }

        function randomizeWorldSeed() {
            const newSeed = Math.floor(Math.random() * 1000000);
            document.getElementById('world-seed-input').value = newSeed;
        }

        function applyWorldGenSettings() {
            // Get values from UI
            worldSeed = parseInt(document.getElementById('world-seed-input').value) || Math.floor(Math.random() * 1000000);
            generationParams.wallCount = parseInt(document.getElementById('wall-count').value);
            generationParams.minWallLength = parseInt(document.getElementById('min-wall-length').value);
            generationParams.maxWallLength = parseInt(document.getElementById('max-wall-length').value);
            generationParams.obstacleCount = parseInt(document.getElementById('obstacle-count').value);
            generationParams.minObstacleSize = parseFloat(document.getElementById('min-obstacle-size').value);
            generationParams.maxObstacleSize = parseFloat(document.getElementById('max-obstacle-size').value);

            console.log('Applying new world generation settings:', { worldSeed, generationParams });

            // Regenerate the world
            hideWorldGen();
            createRoom();
        }

        function switchWeapon(weaponType) {
            currentWeapon = weaponType;

            // Hide all weapons
            document.getElementById('pistol-image').style.display = 'none';
            document.getElementById('pistol-fallback').style.display = 'none';
            document.getElementById('rifle-image').style.display = 'none';
            document.getElementById('rifle-fallback').style.display = 'none';

            // Show selected weapon
            if (weaponType === 'pistol') {
                const pistolImg = document.getElementById('pistol-image');
                if (pistolImg.complete && pistolImg.naturalWidth > 0) {
                    pistolImg.style.display = 'block';
                } else {
                    document.getElementById('pistol-fallback').style.display = 'block';
                }
            } else if (weaponType === 'rifle') {
                const rifleImg = document.getElementById('rifle-image');
                if (rifleImg.complete && rifleImg.naturalWidth > 0) {
                    rifleImg.style.display = 'block';
                } else {
                    document.getElementById('rifle-fallback').style.display = 'block';
                }
            }

            // Stop any auto-firing when switching weapons
            isAutoFiring = false;
            if (autoFireInterval) {
                clearInterval(autoFireInterval);
                autoFireInterval = null;
            }

            console.log('Switched to:', weaponType);
        }

        function setupEventListeners() {
            // Mouse controls with pointer lock for better FPS experience
            let isPointerLocked = false;

            // Click handler for starting game and shooting
            renderer.domElement.addEventListener('click', (event) => {
                if (!document.pointerLockElement) {
                    // Request pointer lock and auto-fullscreen
                    console.log('Requesting pointer lock...');
                    renderer.domElement.requestPointerLock();

                    // Auto-enter fullscreen when game begins
                    const container = document.getElementById('canvas-container');
                    if (!document.fullscreenElement) {
                        container.requestFullscreen().then(() => {
                            document.getElementById('fullscreen-btn').textContent = 'Exit Fullscreen';
                            // Resize renderer to fullscreen
                            camera.aspect = window.innerWidth / window.innerHeight;
                            camera.updateProjectionMatrix();
                            renderer.setSize(window.innerWidth, window.innerHeight);
                        }).catch(err => {
                            console.log('Fullscreen failed:', err);
                        });
                    }
                } else if (document.pointerLockElement === renderer.domElement) {
                    // Already in pointer lock - shoot (only for pistol or single shots)
                    if (currentWeapon === 'pistol') {
                        shoot();
                    }
                }
            });

            // Mouse down for shooting (both weapons)
            renderer.domElement.addEventListener('mousedown', (event) => {
                if (document.pointerLockElement === renderer.domElement && event.button === 0) {
                    // First shot for any weapon
                    if (currentWeapon === 'rifle') {
                        shoot(); // Initial rifle shot

                        // Start auto-fire for rifle
                        if (!isAutoFiring) {
                            isAutoFiring = true;
                            autoFireInterval = setInterval(() => {
                                if (isAutoFiring) {
                                    shoot();
                                }
                            }, 250); // 4 rounds per second (1000ms / 4 = 250ms)
                        }
                    }
                    // Pistol shooting is handled by click event
                }
            });

            // Mouse up to stop auto-fire
            renderer.domElement.addEventListener('mouseup', (event) => {
                if (event.button === 0) {
                    isAutoFiring = false;
                    if (autoFireInterval) {
                        clearInterval(autoFireInterval);
                        autoFireInterval = null;
                    }
                }
            });

            // Handle pointer lock changes
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
                console.log('Pointer lock changed:', isPointerLocked, document.pointerLockElement);

                // Show/hide click to play overlay, crosshair, and weapon
                const overlay = document.getElementById('click-to-play');
                const crosshair = document.getElementById('crosshair');
                const weapon = document.getElementById('weapon-display');
                if (isPointerLocked) {
                    console.log('Entering game mode');
                    overlay.style.display = 'none';
                    crosshair.style.display = 'block';
                    weapon.style.display = 'block';
                    // Initialize with pistol
                    switchWeapon('pistol');
                } else {
                    console.log('Exiting game mode');
                    overlay.style.display = 'block';
                    crosshair.style.display = 'none';
                    weapon.style.display = 'none';
                    // Stop auto-firing when losing focus
                    isAutoFiring = false;
                    if (autoFireInterval) {
                        clearInterval(autoFireInterval);
                        autoFireInterval = null;
                    }
                }
            });

            // Mouse movement for looking around
            document.addEventListener('mousemove', (event) => {
                if (!isPointerLocked) return;

                const sensitivity = 0.002;
                yaw -= event.movementX * sensitivity;
                pitch -= event.movementY * sensitivity; // Natural up/down

                // Clamp vertical rotation to prevent flipping
                pitch = Math.max(-maxPitch, Math.min(maxPitch, pitch));

                // Apply rotations to camera
                camera.rotation.order = 'YXZ';
                camera.rotation.y = yaw;
                camera.rotation.x = pitch;
            });

            // Keyboard controls
            document.addEventListener('keydown', (event) => {
                switch (event.code) {
                    case 'KeyW':
                    case 'ArrowUp':
                        moveForward = true;
                        break;
                    case 'KeyS':
                    case 'ArrowDown':
                        moveBackward = true;
                        break;
                    case 'KeyA':
                    case 'ArrowLeft':
                        moveLeft = true;
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        moveRight = true;
                        break;
                    case 'Space':
                        // Jump - check current ground level at player position
                        const playerGroundLevel = getGroundLevelAt(camera.position.x, camera.position.z) + groundLevel;
                        if (!isJumping && camera.position.y <= playerGroundLevel + 0.1) {
                            isJumping = true;
                            verticalVelocity = jumpStrength;
                            playJumpSound();
                        }
                        break;
                    case 'Escape':
                        if (document.getElementById('help-overlay').style.display === 'flex') {
                            hideHelp();
                        } else {
                            document.exitPointerLock();
                        }
                        break;
                    case 'KeyH':
                        toggleHelp();
                        break;
                    case 'Digit1':
                        switchWeapon('rifle');
                        break;
                    case 'Digit2':
                        switchWeapon('pistol');
                        break;
                }
            });

            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW':
                    case 'ArrowUp':
                        moveForward = false;
                        break;
                    case 'KeyS':
                    case 'ArrowDown':
                        moveBackward = false;
                        break;
                    case 'KeyA':
                    case 'ArrowLeft':
                        moveLeft = false;
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        moveRight = false;
                        break;
                }
            });
        }

        let frameCount = 0;
        function animate() {
            requestAnimationFrame(animate);

            // Debug: Log first few frames
            frameCount++;
            if (frameCount <= 3) {
                console.log(`Animation frame ${frameCount}`);
            }

            // Movement speed
            const moveSpeed = 0.04;

            // Apply gravity and jump physics
            const currentGroundLevel = getGroundLevelAt(camera.position.x, camera.position.z) + groundLevel;

            if (isJumping || camera.position.y > currentGroundLevel) {
                verticalVelocity -= gravity;
                camera.position.y += verticalVelocity;

                // Check if landed on ground or object
                if (camera.position.y <= currentGroundLevel) {
                    camera.position.y = currentGroundLevel;
                    verticalVelocity = 0;
                    isJumping = false;
                }
            } else {
                // Ensure player stays on ground/object when walking
                camera.position.y = currentGroundLevel;
            }

            // Calculate movement based on current yaw (horizontal rotation only)
            if (moveForward || moveBackward || moveLeft || moveRight) {
                const movement = new THREE.Vector3(0, 0, 0);

                // Calculate forward/backward movement
                if (moveForward) {
                    movement.x -= Math.sin(yaw) * moveSpeed;
                    movement.z -= Math.cos(yaw) * moveSpeed;
                }
                if (moveBackward) {
                    movement.x += Math.sin(yaw) * moveSpeed;
                    movement.z += Math.cos(yaw) * moveSpeed;
                }

                // Calculate left/right movement (strafe)
                if (moveLeft) {
                    movement.x -= Math.cos(yaw) * moveSpeed;
                    movement.z += Math.sin(yaw) * moveSpeed;
                }
                if (moveRight) {
                    movement.x += Math.cos(yaw) * moveSpeed;
                    movement.z -= Math.sin(yaw) * moveSpeed;
                }

                // Apply movement with collision detection
                const newPosition = camera.position.clone();
                newPosition.add(movement);

                // Check collision separately for X and Z movement for wall sliding
                const testPositionX = camera.position.clone();
                testPositionX.x = newPosition.x;

                const testPositionZ = camera.position.clone();
                testPositionZ.z = newPosition.z;

                if (!checkCollision(testPositionX, camera.position.y)) {
                    camera.position.x = newPosition.x;
                }

                if (!checkCollision(testPositionZ, camera.position.y)) {
                    camera.position.z = newPosition.z;
                }
            }

            // Make all living enemies face the player and move (only host controls enemies)
            if (!isMultiplayer || isHost) {
                let enemiesChanged = false;

                enemies.forEach((enemy, index) => {
                    if (enemy.userData.alive) {
                        // Always face the player
                        enemy.lookAt(camera.position);

                        // Simple AI movement
                        enemy.userData.changeDirectionTimer--;
                        if (enemy.userData.changeDirectionTimer <= 0) {
                            enemy.userData.direction = Math.random() * Math.PI * 2;
                            enemy.userData.changeDirectionTimer = 100 + Math.random() * 200;
                            enemiesChanged = true;
                            if (frameCount % 300 === 0) { // Debug every 5 seconds
                                console.log(`Enemy ${index + 1} changing direction to ${enemy.userData.direction}`);
                            }
                        }

                        // Move enemy
                        const moveX = Math.sin(enemy.userData.direction) * enemy.userData.speed;
                        const moveZ = Math.cos(enemy.userData.direction) * enemy.userData.speed;

                        const newPos = enemy.position.clone();
                        newPos.x += moveX;
                        newPos.z += moveZ;

                        // Check collision for enemy movement
                        if (!checkCollision(newPos)) {
                            enemy.position.x = newPos.x;
                            enemy.position.z = newPos.z;
                            enemiesChanged = true;
                        } else {
                            // Bounce off walls and obstacles
                            enemy.userData.direction += Math.PI + (Math.random() - 0.5) * 0.5;
                            enemy.userData.changeDirectionTimer = 50; // Change direction soon
                            enemiesChanged = true;
                            if (frameCount % 300 === 0) { // Debug collision bounces
                                console.log(`Enemy ${index + 1} bounced off obstacle`);
                            }
                        }
                    }
                });

                // Send enemy updates to other players if host and something changed
                if (isMultiplayer && isHost && enemiesChanged && frameCount % 10 === 0) { // Send updates every 10 frames
                    if (multiplayerClient && multiplayerClient.isMultiplayerActive()) {
                        multiplayerClient.sendEnemyUpdate(enemies);
                    }
                }
            } else {
                // Non-host clients: just make enemies face the player
                enemies.forEach((enemy) => {
                    if (enemy.userData.alive) {
                        enemy.lookAt(camera.position);
                    }
                });
            }

            // RACCOON CHASERS AI - Loop through all raccoons
            raccoonChasers.forEach((raccoonChaser, index) => {
                if (raccoonChaser && raccoonChaser.userData.active) {
                    // Make raccoon face the player
                    raccoonChaser.lookAt(camera.position);

                    // Make health bar face the player
                    if (raccoonChaser.userData.healthBarGroup) {
                        raccoonChaser.userData.healthBarGroup.lookAt(camera.position);
                    }

                    // Update health bar scale based on current health
                    if (raccoonChaser.userData.healthBar) {
                        const healthPercent = raccoonChaser.userData.health / raccoonChaser.userData.maxHealth;
                        raccoonChaser.userData.healthBar.scale.x = healthPercent;
                        raccoonChaser.userData.healthBar.position.x = -(3 * (1 - healthPercent)) / 2;

                        // Change color based on health
                        if (healthPercent > 0.6) {
                            raccoonChaser.userData.healthBar.material.color.setHex(0x00ff00); // Green
                        } else if (healthPercent > 0.3) {
                            raccoonChaser.userData.healthBar.material.color.setHex(0xffff00); // Yellow
                        } else {
                            raccoonChaser.userData.healthBar.material.color.setHex(0xff8800); // Orange
                        }
                    }

                    // Check if raccoon is dead
                    if (raccoonChaser.userData.health <= 0) {
                        // Increment global kill counter
                        totalKillCount++;
                        raccoonChaser.userData.killCount++;

                        // Check if we should spawn a new raccoon (every 5 kills)
                        if (totalKillCount % 5 === 0) {
                            const roomBound = 40;
                            const spawnX = (Math.random() - 0.5) * roomBound * 2;
                            const spawnZ = (Math.random() - 0.5) * roomBound * 2;
                            createRaccoon(spawnX, spawnZ);
                            console.log(`MILESTONE! ${totalKillCount} kills - New raccoon spawned! Total raccoons: ${raccoonChasers.length}`);
                        }

                        // Increase max health by 25% each death (100 -> 125 -> 156 -> 195...)
                        raccoonChaser.userData.maxHealth = Math.floor(raccoonChaser.userData.baseMaxHealth * Math.pow(1.25, raccoonChaser.userData.killCount));

                        // Increase speed by 5% each death (0.038 -> 0.0399 -> 0.0419...)
                        raccoonChaser.userData.speed = raccoonChaser.userData.baseSpeed * Math.pow(1.05, raccoonChaser.userData.killCount);

                        // Respawn raccoon at random location
                        const roomBound = 40;
                        const newX = (Math.random() - 0.5) * roomBound * 2;
                        const newZ = (Math.random() - 0.5) * roomBound * 2;
                        raccoonChaser.position.set(newX, 1, newZ);

                        // Reset health to new max
                        raccoonChaser.userData.health = raccoonChaser.userData.maxHealth;

                        console.log(`Raccoon #${index + 1} defeated! Total kills: ${totalKillCount}. Respawning at (${newX.toFixed(1)}, ${newZ.toFixed(1)})`);
                        console.log(`New stats - Health: ${raccoonChaser.userData.maxHealth}, Speed: ${raccoonChaser.userData.speed.toFixed(4)}`);
                    } else {
                        // Calculate direction to player
                        const directionToPlayer = new THREE.Vector3();
                        directionToPlayer.subVectors(camera.position, raccoonChaser.position);
                        directionToPlayer.y = 0; // Keep movement horizontal
                        directionToPlayer.normalize();

                        // Move towards player (phases through walls for horror effect)
                        const raccoonSpeed = raccoonChaser.userData.speed;
                        raccoonChaser.position.x += directionToPlayer.x * raccoonSpeed;
                        raccoonChaser.position.z += directionToPlayer.z * raccoonSpeed;

                        // Check if raccoon caught the player (game over)
                        const distanceToPlayer = raccoonChaser.position.distanceTo(camera.position);
                        if (distanceToPlayer < 2) {
                            // Player caught by raccoon!
                            playerHealth = 0;
                            updateHealthBar();
                            console.log('GAME OVER: Caught by the raccoon!');
                        }
                    }
                }
            });

            // Update flashlight position and direction to follow camera
            if (playerLight) {
                playerLight.position.copy(camera.position);

                // Get the camera's forward direction vector
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);

                // Position the spotlight target in front of the camera
                playerLight.target.position.copy(camera.position).add(direction.multiplyScalar(10));
                playerLight.target.updateMatrixWorld();
            }

            // Send multiplayer updates
            if (isMultiplayer && multiplayerClient && multiplayerClient.isMultiplayerActive()) {
                multiplayerClient.sendPlayerUpdate(
                    camera.position,
                    { yaw: yaw, pitch: pitch },
                    currentWeapon
                );
            }

            // Update UI and minimap
            updateUI();
            updateMinimap();

            // Render scene
            renderer.render(scene, camera);
        }

        // Network player callback functions
        window.onNetworkPlayerJoined = function(player) {
            console.log(`Creating visual for network player: ${player.name}`);

            // Create stick figure player model
            const playerGroup = new THREE.Group();

            // Create stick figure using canvas (similar to your image)
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 96;
            canvas.height = 256;

            // Clear canvas
            ctx.fillStyle = 'rgba(0,0,0,0)';
            ctx.fillRect(0, 0, 96, 256);

            // Draw stick figure
            ctx.strokeStyle = '#00AAFF'; // Blue color for network players
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            const centerX = 48;
            const scale = 0.8;

            // Head (circle)
            ctx.beginPath();
            ctx.arc(centerX, 40 * scale, 15 * scale, 0, Math.PI * 2);
            ctx.stroke();

            // Body (vertical line)
            ctx.beginPath();
            ctx.moveTo(centerX, 55 * scale);
            ctx.lineTo(centerX, 140 * scale);
            ctx.stroke();

            // Arms (horizontal line)
            ctx.beginPath();
            ctx.moveTo(centerX - 20 * scale, 85 * scale);
            ctx.lineTo(centerX + 20 * scale, 85 * scale);
            ctx.stroke();

            // Left leg
            ctx.beginPath();
            ctx.moveTo(centerX, 140 * scale);
            ctx.lineTo(centerX - 15 * scale, 180 * scale);
            ctx.stroke();

            // Right leg
            ctx.beginPath();
            ctx.moveTo(centerX, 140 * scale);
            ctx.lineTo(centerX + 15 * scale, 180 * scale);
            ctx.stroke();

            // Add player name
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.strokeText(player.name, centerX, 200);
            ctx.fillText(player.name, centerX, 200);

            const texture = new THREE.CanvasTexture(canvas);
            const playerMaterial = new THREE.MeshPhongMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide,
                alphaTest: 0.1
            });

            const playerGeometry = new THREE.PlaneGeometry(0.8, 1.6);
            const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
            playerMesh.position.set(player.position.x, player.position.y, player.position.z);
            playerMesh.castShadow = true;

            player.mesh = playerMesh;
            networkPlayers.set(player.id, player);
            roomGroup.add(playerMesh);
        };

        window.onNetworkPlayerUpdate = function(player) {
            if (player.mesh) {
                player.mesh.position.set(player.position.x, player.position.y, player.position.z);
                player.mesh.lookAt(camera.position); // Always face camera like enemies
            }
        };

        window.onNetworkPlayerShoot = function(player, origin, direction, weapon) {
            console.log(`Network player ${player.name} shot with ${weapon}`);
            // Reuse existing muzzle flash effect
            createBulletPath(false); // Show bullet path without hit
        };

        window.onNetworkPlayerLeft = function(player) {
            console.log(`Network player ${player.name} left`);
            if (player.mesh) {
                roomGroup.remove(player.mesh);
            }
            networkPlayers.delete(player.id);
        };

        // Host status callback
        window.onHostStatusChanged = function(hostStatus) {
            isHost = hostStatus;
            console.log(`üéÆ Host status: ${isHost ? 'HOST' : 'CLIENT'}`);
        };

        // Enemy update callback
        window.onEnemyUpdate = function(data) {
            if (isHost) return; // Host doesn't receive updates

            console.log(`üì° Received enemy update:`, data);

            // Update enemies based on host data
            data.enemies.forEach(enemyData => {
                const enemy = enemies.find(e => e.userData.id === enemyData.id);
                if (enemy) {
                    enemy.position.set(enemyData.position.x, enemyData.position.y, enemyData.position.z);
                    enemy.userData.direction = enemyData.direction;
                    enemy.userData.alive = enemyData.alive;

                    if (!enemyData.alive && enemy.userData.alive) {
                        // Enemy just died, trigger death animation
                        enemy.userData.alive = false;
                        enemy.material.color.setRGB(0.3, 0.3, 0.3);
                        enemy.material.opacity = 0.7;
                    }
                }
            });
        };

        // CI/CD Test Functions
        function testShooting() {
            // Test if shooting mechanics are functional
            return shotsFired > 0;
        }

        function testMultiplayer() {
            // Test if multiplayer system is initialized (exists and has socket capability)
            return typeof multiplayerClient !== 'undefined' && multiplayerClient !== null;
        }

        function testEnemyInteraction() {
            // Test if single enemy exists (PvP mode has only 1 enemy)
            return enemies.length === 1 || (enemies.length >= 0 && shotsHit > 0);
        }

        function test3DMechanics() {
            // Test if 3D mechanics are functional (scene, camera, renderer exist and working)
            return typeof scene !== 'undefined' && scene !== null &&
                   typeof camera !== 'undefined' && camera !== null &&
                   typeof renderer !== 'undefined' && renderer !== null &&
                   roomGroup !== null;
        }

        function testPvPCombat() {
            // Test if PvP combat system is functional (HP system and multiplayer hit detection)
            return typeof playerHealth !== 'undefined' &&
                   playerHealth >= 0 &&
                   playerHealth <= maxPlayerHealth &&
                   typeof takeDamage === 'function';
        }


        function runCICDTests() {
            // Reset all status indicators
            document.getElementById('test-shooting-status').className = 'cicd-test-status pending';
            document.getElementById('test-multiplayer-status').className = 'cicd-test-status pending';
            document.getElementById('test-pvp-status').className = 'cicd-test-status pending';
            document.getElementById('test-enemy-status').className = 'cicd-test-status pending';
            document.getElementById('test-3d-status').className = 'cicd-test-status pending';
            document.getElementById('test-shooting-status').textContent = '';
            document.getElementById('test-multiplayer-status').textContent = '';
            document.getElementById('test-pvp-status').textContent = '';
            document.getElementById('test-enemy-status').textContent = '';
            document.getElementById('test-3d-status').textContent = '';

            // Run all tests
            const results = {
                shooting: testShooting(),
                multiplayer: testMultiplayer(),
                pvpCombat: testPvPCombat(),
                enemyInteraction: testEnemyInteraction(),
                mechanics3D: test3DMechanics()
            };

            // Update status indicators
            if (results.shooting) {
                document.getElementById('test-shooting-status').className = 'cicd-test-status pass';
                document.getElementById('test-shooting-status').textContent = '‚úì';
            } else {
                document.getElementById('test-shooting-status').className = 'cicd-test-status fail';
                document.getElementById('test-shooting-status').textContent = '‚úó';
            }

            if (results.multiplayer) {
                document.getElementById('test-multiplayer-status').className = 'cicd-test-status pass';
                document.getElementById('test-multiplayer-status').textContent = '‚úì';
            } else {
                document.getElementById('test-multiplayer-status').className = 'cicd-test-status fail';
                document.getElementById('test-multiplayer-status').textContent = '‚úó';
            }

            if (results.pvpCombat) {
                document.getElementById('test-pvp-status').className = 'cicd-test-status pass';
                document.getElementById('test-pvp-status').textContent = '‚úì';
            } else {
                document.getElementById('test-pvp-status').className = 'cicd-test-status fail';
                document.getElementById('test-pvp-status').textContent = '‚úó';
            }

            if (results.enemyInteraction) {
                document.getElementById('test-enemy-status').className = 'cicd-test-status pass';
                document.getElementById('test-enemy-status').textContent = '‚úì';
            } else {
                document.getElementById('test-enemy-status').className = 'cicd-test-status fail';
                document.getElementById('test-enemy-status').textContent = '‚úó';
            }

            if (results.mechanics3D) {
                document.getElementById('test-3d-status').className = 'cicd-test-status pass';
                document.getElementById('test-3d-status').textContent = '‚úì';
            } else {
                document.getElementById('test-3d-status').className = 'cicd-test-status fail';
                document.getElementById('test-3d-status').textContent = '‚úó';
            }

            // Display results
            displayTestResults(results);
        }

        function displayTestResults(results) {
            const allPassed = results.shooting && results.multiplayer && results.pvpCombat && results.enemyInteraction && results.mechanics3D && results.spikeMechanics;
            const resultsDiv = document.getElementById('cicd-results');
            const messageDiv = document.getElementById('cicd-results-message');
            const detailsDiv = document.getElementById('cicd-results-details');

            resultsDiv.style.display = 'block';

            if (allPassed) {
                resultsDiv.className = 'cicd-results success';
                messageDiv.textContent = '‚úì Tests succeeded';
                detailsDiv.innerHTML = '<p>All game systems are operational and ready for deployment!</p>';
            } else {
                resultsDiv.className = 'cicd-results failure';
                messageDiv.textContent = '‚úó Tests failed';

                const failures = [];
                if (!results.shooting) {
                    failures.push('‚Ä¢ Shooting Mechanics: No shots fired. Try shooting with the pistol or rifle.');
                }
                if (!results.multiplayer) {
                    failures.push('‚Ä¢ Multiplayer System: Not initialized. Multiplayer client not found.');
                }
                if (!results.pvpCombat) {
                    failures.push('‚Ä¢ PvP Combat: HP system not initialized. Player health tracking unavailable.');
                }
                if (!results.enemyInteraction) {
                    failures.push('‚Ä¢ Single Enemy: Enemy not spawned. Expected exactly 1 enemy in PvP mode.');
                }
                if (!results.mechanics3D) {
                    failures.push('‚Ä¢ 3D Mechanics: Core 3D components missing or not initialized.');
                }
                if (!results.spikeMechanics) {
                    failures.push('‚Ä¢ Spike System: Valorant-style spike mechanics not initialized.');
                }

                detailsDiv.innerHTML = '<p><strong>Failed Tests:</strong></p>' + failures.map(f => `<p>${f}</p>`).join('');
            }
        }

        function showCICDPanel() {
            document.getElementById('cicd-overlay').style.display = 'flex';
        }

        function hideCICDPanel() {
            document.getElementById('cicd-overlay').style.display = 'none';
        }

        // Initialize when page loads
        window.addEventListener('load', () => {
            init();

            // Check for multiplayer parameters
            const urlParams = new URLSearchParams(window.location.search);
            const roomId = urlParams.get('room');
            const playerNameParam = urlParams.get('name');

            if (roomId && playerNameParam) {
                isMultiplayer = true;
                playerName = playerNameParam;
                multiplayerClient = new MultiplayerClient();

                console.log(`Setting up multiplayer for room: ${roomId} as ${playerName}`);

                // Connect and wait for connection before joining room
                multiplayerClient.connect();

                // Listen for player hit events
                multiplayerClient.socket.on('playerHit', (data) => {
                    console.log(`Hit by ${data.shooterName} for ${data.damage} damage!`);
                    takeDamage(data.damage);
                });

                // Wait for connection, then join room
                setTimeout(() => {
                    if (multiplayerClient.isConnected) {
                        console.log('Connected! Joining room...');
                        multiplayerClient.joinRoom(roomId, playerName);
                    } else {
                        console.log('Not connected yet, retrying...');
                        setTimeout(() => {
                            if (multiplayerClient.isConnected) {
                                multiplayerClient.joinRoom(roomId, playerName);
                            } else {
                                console.error('Failed to connect to multiplayer server');
                            }
                        }, 1000);
                    }
                }, 500);
            }
        });
    </script>
</body>
</html>